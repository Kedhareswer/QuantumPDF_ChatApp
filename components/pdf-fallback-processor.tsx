"use client"

import type React from "react"
import { useState, useRef } from "react"
import { Upload, FileText, Loader2, CheckCircle, AlertCircle, Info } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Progress } from "@/components/ui/progress"
import { Alert, AlertDescription } from "@/components/ui/alert"

interface Document {
  id: string
  name: string
  content: string
  chunks: string[]
  embeddings: number[][]
  uploadedAt: Date
  metadata?: Record<string, any> // More specific than any
}

interface PDFInfo {
  Title?: string;
  Author?: string;
  Subject?: string;
  [key: string]: any; // Allow other properties
}

interface PDFDocumentMetadata {
  info?: PDFInfo;
  [key: string]: any; // Allow other properties
}

interface PDFFallbackProcessorProps {
  onDocumentProcessed: (document: Document) => void
  isProcessing: boolean
  setIsProcessing: (processing: boolean) => void
}

export function PDFFallbackProcessor({
  onDocumentProcessed,
  isProcessing,
  setIsProcessing,
}: PDFFallbackProcessorProps) {
  const [uploadProgress, setUploadProgress] = useState(0)
  const [processingStage, setProcessingStage] = useState("")
  const [error, setError] = useState<string | null>(null)
  const [showFallbackInfo, setShowFallbackInfo] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) {
      setError("No file selected")
      return
    }

    if (file.type !== "application/pdf") {
      setError("Please select a PDF file")
      return
    }

    if (file.size > 10 * 1024 * 1024) {
      setError("File size exceeds 10MB limit")
      return
    }

    setIsProcessing(true)
    setUploadProgress(0)
    setError(null)
    setShowFallbackInfo(false)

    try {
      // Try client-side processing first
      await processWithClientSide(file)
    } catch (clientError) {
      console.warn("Client-side processing failed, trying server-side:", clientError)
      setShowFallbackInfo(true)

      try {
        await processWithServerSide(file)
      } catch (serverError) {
        console.error("Both client and server processing failed:", serverError)
        setError("Failed to process PDF. Please try a different file or check your internet connection.")
      }
    } finally {
      setTimeout(() => {
        setIsProcessing(false)
        setUploadProgress(0)
        setProcessingStage("")
        setError(null)
        setShowFallbackInfo(false)
      }, 1000)
    }
  }

  const processWithClientSide = async (file: File) => {
    setProcessingStage("Loading PDF.js...")
    setUploadProgress(10)

    // Dynamic import to handle potential loading issues
    const pdfjsLib = await import("pdfjs-dist")

    // Set worker with fallback URLs
    if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
      const workerUrls = [
        `https://unpkg.com/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.js`,
        `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`,
        `https://cdn.jsdelivr.net/npm/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.js`,
      ]

      // Try each worker URL until one works
      for (const workerUrl of workerUrls) {
        try {
          pdfjsLib.GlobalWorkerOptions.workerSrc = workerUrl
          break
        } catch (e) {
          console.warn(`Failed to load worker from ${workerUrl}:`, e)
        }
      }
    }

    setProcessingStage("Extracting text from PDF...")
    setUploadProgress(30)

    const arrayBuffer = await file.arrayBuffer()
    const loadingTask = pdfjsLib.getDocument({
      data: arrayBuffer,
      cMapUrl: `https://unpkg.com/pdfjs-dist@${pdfjsLib.version}/cmaps/`,
      cMapPacked: true,
    })

    const pdf = await loadingTask.promise
    const metadata: PDFDocumentMetadata = await pdf.getMetadata();
    let fullText = ""

    // Extract text from all pages
    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
      const page = await pdf.getPage(pageNum)
      const textContent = await page.getTextContent()

      const pageText = textContent.items.map((item: any) => ("str" in item ? item.str : "")).join(" ")

      if (pageText.trim()) {
        fullText += `\n\n--- Page ${pageNum} ---\n${pageText}`
      }

      // Update progress
      setUploadProgress(30 + (pageNum / pdf.numPages) * 40)
    }

    if (!fullText.trim()) {
      throw new Error("No text found in PDF")
    }

    setProcessingStage("Processing text chunks...")
    setUploadProgress(80)

    // Create chunks
    const chunks = chunkText(fullText.trim())

    setProcessingStage("Finalizing...")
    setUploadProgress(100)

    const document: Document = {
      id: Date.now().toString(),
      name: file.name,
      content: fullText.trim(),
      chunks,
      embeddings: [], // Will be generated by RAG engine
      uploadedAt: new Date(),
      metadata: {
        title: metadata.info?.Title,
        author: metadata.info?.Author,
        subject: metadata.info?.Subject,
        pages: pdf.numPages,
      },
    }

    onDocumentProcessed(document)

    // Reset file input
    if (fileInputRef.current) {
      fileInputRef.current.value = ""
    }

    setProcessingStage("Complete!")
  }

  const processWithServerSide = async (file: File) => {
    setProcessingStage("Uploading to server...")
    setUploadProgress(20)

    const formData = new FormData()
    formData.append("pdf", file)

    const response = await fetch("/api/pdf/extract", {
      method: "POST",
      body: formData,
    })

    if (!response.ok) {
      throw new Error(`Server processing failed: ${response.statusText}`)
    }

    setProcessingStage("Server processing...")
    setUploadProgress(60)

    const data = await response.json()

    if (!data.success) {
      throw new Error(data.error || "Server processing failed")
    }

    setProcessingStage("Finalizing...")
    setUploadProgress(100)

    const document: Document = {
      id: Date.now().toString(),
      name: file.name,
      content: data.text,
      chunks: data.chunks,
      embeddings: [],
      uploadedAt: new Date(),
      metadata: data.metadata,
    }

    onDocumentProcessed(document)

    // Reset file input
    if (fileInputRef.current) {
      fileInputRef.current.value = ""
    }

    setProcessingStage("Complete!")
  }

  const chunkText = (text: string, chunkSize = 500, overlap = 50): string[] => {
    const sentences = text.split(/[.!?]+/).filter((s) => s.trim().length > 0)
    const chunks: string[] = []
    let currentChunk = ""

    for (const sentence of sentences) {
      const trimmedSentence = sentence.trim()
      if (!trimmedSentence) continue

      const potentialChunk = currentChunk + (currentChunk ? ". " : "") + trimmedSentence

      if (potentialChunk.length <= chunkSize) {
        currentChunk = potentialChunk
      } else {
        if (currentChunk) {
          chunks.push(currentChunk + ".")
        }
        currentChunk = trimmedSentence
      }
    }

    if (currentChunk) {
      chunks.push(currentChunk + ".")
    }

    return chunks.filter((chunk) => chunk.trim().length > 0)
  }

  return (
    <div className="space-y-4">
      <div className="border-2 border-dashed border-black p-6 text-center">
        <input
          ref={fileInputRef}
          type="file"
          accept=".pdf"
          onChange={handleFileUpload}
          className="hidden"
          disabled={isProcessing}
        />

        {error && (
          <div className="mb-4 p-3 border border-red-500 bg-red-50 text-red-700 text-sm">
            <div className="flex items-center space-x-2">
              <AlertCircle className="w-4 h-4" />
              <span>{error}</span>
            </div>
          </div>
        )}

        {showFallbackInfo && (
          <Alert className="mb-4">
            <Info className="h-4 w-4" />
            <AlertDescription>Client-side processing failed. Trying server-side processing...</AlertDescription>
          </Alert>
        )}

        {!isProcessing ? (
          <div className="space-y-3">
            <FileText className="w-12 h-12 mx-auto text-gray-600" />
            <div>
              <p className="font-medium">UPLOAD PDF DOCUMENT</p>
              <p className="text-sm text-gray-600 mt-1">Click to select a PDF file for processing</p>
              <p className="text-xs text-gray-500 mt-1">Supports text-based PDFs up to 10MB</p>
            </div>
            <Button
              onClick={() => fileInputRef.current?.click()}
              variant="outline"
              className="border-black text-black hover:bg-black hover:text-white"
            >
              <Upload className="w-4 h-4 mr-2" />
              SELECT FILE
            </Button>
          </div>
        ) : (
          <div className="space-y-3">
            {uploadProgress === 100 ? (
              <CheckCircle className="w-12 h-12 mx-auto text-green-600" />
            ) : (
              <Loader2 className="w-12 h-12 mx-auto animate-spin" />
            )}
            <div>
              <p className="font-medium">PROCESSING DOCUMENT</p>
              <p className="text-sm text-gray-600 mt-1">{processingStage}</p>
            </div>
            <Progress value={uploadProgress} className="w-full" />
            <p className="text-xs text-gray-500">{uploadProgress}% complete</p>
          </div>
        )}
      </div>
    </div>
  )
}
